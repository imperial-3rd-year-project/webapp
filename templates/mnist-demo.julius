document.getElementById(#{toJSON aDomId}).innerHTML = "This text was added by the Javascript part of the homepage widget.";

var canvas, ctx, flag = false,
		prevX = 0,
		currX = 0,
		prevY = 0,
		currY = 0,
		dot_flag = false;

const colour = "black",
		  thickness = 10;

var imageData = [];

window.onload = function() {
	canvas = document.getElementById(#{toJSON canvasId});
	ctx = canvas.getContext("2d");
	w = canvas.width;
	h = canvas.height;

	canvas.addEventListener("mousemove", function (e) {
			findxy('move', e)
	}, false);
	canvas.addEventListener("mousedown", function (e) {
			findxy('down', e)
	}, false);
	canvas.addEventListener("mouseup", function (e) {
			findxy('up', e)
	}, false);
	canvas.addEventListener("mouseout", function (e) {
			findxy('out', e)
	}, false);
};


function draw() {
		ctx.beginPath();
		//ctx.moveTo(prevX, prevY);
		//ctx.lineTo(currX, currY);
		//ctx.strokeStyle = colour;
		//ctx.lineWidth = thickness;
		//ctx.stroke();
		//ctx.closePath();
    ctx.arc(currX, currY, thickness, 0, 6);
    ctx.fill();
    ctx.closePath();
}

function erase() {
		ctx.clearRect(0, 0, w, h);
}

function findxy(res, e) {
		if (res == 'down') {
				prevX = currX;
				prevY = currY;
				const {x, y} = canvas.getBoundingClientRect();
				currX = e.clientX - x;
				currY = e.clientY - y;
        //ctx.beginPath();

				flag = true;
				//dot_flag = true;
				//if (dot_flag) {
				//		ctx.beginPath();
				//		ctx.fillStyle = colour;
				//		ctx.fillRect(currX, currY, 2, 2);
				//		ctx.closePath();
				//		dot_flag = false;
				//}
		}
		if (res == 'up' || res == "out") {
        ctx.closePath();
				flag = false;
				sendCanvasBytes(e);
		}
		if (res == 'move') {
				if (flag) {
						prevX = currX;
						prevY = currY;
						const {x, y} = canvas.getBoundingClientRect();
						currX = e.clientX - x;
						currY = e.clientY - y;
						draw();
				}
		}
}

function sendCanvasBytes(event) {
  function base64EncodeUnicode(str) {
      // First we escape the string using encodeURIComponent to get the UTF-8 encoding of the characters, 
      // then we convert the percent encodings into raw bytes, and finally feed it to btoa() function.
      utf8Bytes = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
              return String.fromCharCode('0x' + p1);
      });
  
      return btoa(utf8Bytes);
  }


	event.preventDefault();
	//const canvasData = ctx.getImageData(0,0,w,h);
  //const canvasBuffer = canvasData.data.buffer;
  //const canvasDataString = new TextDecoder("ascii").decode(canvasBuffer);
  //const savnac = new TextEncoder("utf-8").encode(canvasDataString);
	//console.log("data");
	//console.log(canvasData.data);
  //console.log(base64EncodeUnicode(canvasDataString));
  //console.log(savnac);
  //console.log(canvasBuffer.toString());

  const canvasData = ctx.getImageData(0,0,w,h);
  const canvasBuffer = canvasData.data.buffer;
  const base64Canvas = btoa(String.fromCharCode.apply(null, canvasData.data));
  console.log(base64Canvas);

	let postData = JSON.stringify(base64Canvas);

	$.ajax({
		url: '@{MnistResponseR}',
		type: 'POST',
		contentType: "application/json",
		data: postData,
		success: function (data) {
			console.log("data ?");
			console.log(data);
			document.getElementById(#{toJSON mnistDataId}).innerHTML = data;

		},
		error: function (data) {
			console.log("Error creating comment: " + data.canvasData);
		},
	});
}


