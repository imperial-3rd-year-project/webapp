var canvas, ctx, flag = false,
		prevX = 0,
		currX = 0,
		prevY = 0,
		currY = 0,
		dot_flag = false;

const colour = "black",
		  thickness = 10;

var imageData = [];

window.onload = function() {
	canvas = document.getElementById(#{toJSON canvasId});
	ctx = canvas.getContext("2d");
	w = canvas.width;
	h = canvas.height;

	canvas.addEventListener("mousemove", function (e) {
			findxy('move', e)
	}, false);
	canvas.addEventListener("mousedown", function (e) {
			findxy('down', e)
	}, false);
	canvas.addEventListener("mouseup", function (e) {
			findxy('up', e)
	}, false);
	canvas.addEventListener("mouseout", function (e) {
			findxy('out', e)
	}, false);
};


function draw() {
/*
		ctx.beginPath();
		ctx.moveTo(prevX, prevY);
		ctx.arc(prevX, prevY, thickness, 0, 6);
        ctx.lineTo(currX, currY);
		ctx.strokeStyle = colour;
		ctx.lineWidth = thickness * 2;
		ctx.stroke();
		ctx.closePath();

        ctx.beginPath();
        ctx.arc(currX, currY, thickness, 0, 6);
        ctx.fill();
        ctx.closePath();
*/
        const mouseX = currX;
        const mouseY = currY;
        const lastX = prevX;
        const lastY = prevY;

        // find all points between        
        var x1 = mouseX,
            x2 = lastX,
            y1 = mouseY,
            y2 = lastY;


        var steep = (Math.abs(y2 - y1) > Math.abs(x2 - x1));
        if (steep){
            var x = x1;
            x1 = y1;
            y1 = x;

            var y = y2;
            y2 = x2;
            x2 = y;
        }
        if (x1 > x2) {
            var x = x1;
            x1 = x2;
            x2 = x;

            var y = y1;
            y1 = y2;
            y2 = y;
        }

        var dx = x2 - x1,
            dy = Math.abs(y2 - y1),
            error = 0,
            de = dy / dx,
            yStep = -1,
            y = y1;
        
        if (y1 < y2) {
            yStep = 1;
        }
       
        lineThickness = 15;
       
        for (var x = x1; x < x2; x++) {
            ctx.beginPath();
            if (steep) {
                ctx.arc(y, x, lineThickness, 0, 6);
                ctx.fill();
                //ctx.fillRect(y, x, lineThickness , lineThickness );
            } else {
                ctx.arc(x, y, lineThickness, 0, 6);
                ctx.fill();
                //ctx.fillRect(x, y, lineThickness , lineThickness );
            }
            ctx.closePath();
            error += de;
            if (error >= 0.5) {
                y += yStep;
                error -= 1.0;
            }
        }

}

function erase() {
		ctx.clearRect(0, 0, w, h);
}

function findxy(res, e) {
		if (res == 'down') {
				prevX = currX;
				prevY = currY;
				const {x, y} = canvas.getBoundingClientRect();
				currX = e.clientX - x;
				currY = e.clientY - y;
                //ctx.beginPath();

				flag = true;
				//dot_flag = true;
				//if (dot_flag) {
				//		ctx.beginPath();
				//		ctx.fillStyle = colour;
				//		ctx.fillRect(currX, currY, 2, 2);
				//		ctx.closePath();
				//		dot_flag = false;
				//}
		}
		if (res == 'up' || res == "out") {
                //ctx.closePath();
				flag = false;
				sendCanvasBytes(e);
		}
		if (res == 'move') {
				if (flag) {
						prevX = currX;
						prevY = currY;
						const {x, y} = canvas.getBoundingClientRect();
						currX = e.clientX - x;
						currY = e.clientY - y;
						draw();
				}
		}
}

function sendCanvasBytes(event) {
  function base64EncodeUnicode(str) {
      // First we escape the string using encodeURIComponent to get the UTF-8 encoding of the characters, 
      // then we convert the percent encodings into raw bytes, and finally feed it to btoa() function.
      utf8Bytes = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
              return String.fromCharCode('0x' + p1);
      });
  
      return btoa(utf8Bytes);
  }


	event.preventDefault();
	//const canvasData = ctx.getImageData(0,0,w,h);
  //const canvasBuffer = canvasData.data.buffer;
  //const canvasDataString = new TextDecoder("ascii").decode(canvasBuffer);
  //const savnac = new TextEncoder("utf-8").encode(canvasDataString);
	//console.log("data");
	//console.log(canvasData.data);
  //console.log(base64EncodeUnicode(canvasDataString));
  //console.log(savnac);
  //console.log(canvasBuffer.toString());

  const canvasData = ctx.getImageData(0,0,w,h);
  const canvasBuffer = canvasData.data.buffer;
  // const base64Canvas = btoa(String.fromCharCode.apply(null, canvasData.data));
  var convertedCanvas = [];
  canvasData.data.forEach(function(byte) {convertedCanvas.push(String.fromCharCode(byte))});
  const base64Canvas = btoa(convertedCanvas);
  //console.log(base64Canvas);

	let postData = JSON.stringify(base64Canvas);
    console.log("POSTDATA:");
    console.log(postData);

	$.ajax({
		url: '@{MnistResponseR}',
		type: 'POST',
		contentType: "application/json",
		data: postData,
		success: function (data) {
			console.log("data ?");
			console.log(data);
			document.getElementById(#{toJSON mnistDataId}).innerHTML = data;

		},
		error: function (data) {
			console.log("Error creating comment: " + data);
		},
	});
}


